// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package openoffload_v1alpha2

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion6

// SessionTableClient is the client API for SessionTable service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type SessionTableClient interface {
	// Adds a session
	AddSession(ctx context.Context, in *SessionRequest, opts ...grpc.CallOption) (*AddSessionResponse, error)
	// Obtains the session
	GetSession(ctx context.Context, in *SessionId, opts ...grpc.CallOption) (*SessionResponse, error)
	// Delete a session
	DeleteSession(ctx context.Context, in *SessionId, opts ...grpc.CallOption) (*SessionResponse, error)
}

type sessionTableClient struct {
	cc grpc.ClientConnInterface
}

func NewSessionTableClient(cc grpc.ClientConnInterface) SessionTableClient {
	return &sessionTableClient{cc}
}

func (c *sessionTableClient) AddSession(ctx context.Context, in *SessionRequest, opts ...grpc.CallOption) (*AddSessionResponse, error) {
	out := new(AddSessionResponse)
	err := c.cc.Invoke(ctx, "/openoffload.v1alpha2.SessionTable/addSession", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sessionTableClient) GetSession(ctx context.Context, in *SessionId, opts ...grpc.CallOption) (*SessionResponse, error) {
	out := new(SessionResponse)
	err := c.cc.Invoke(ctx, "/openoffload.v1alpha2.SessionTable/getSession", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sessionTableClient) DeleteSession(ctx context.Context, in *SessionId, opts ...grpc.CallOption) (*SessionResponse, error) {
	out := new(SessionResponse)
	err := c.cc.Invoke(ctx, "/openoffload.v1alpha2.SessionTable/deleteSession", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SessionTableServer is the server API for SessionTable service.
// All implementations must embed UnimplementedSessionTableServer
// for forward compatibility
type SessionTableServer interface {
	// Adds a session
	AddSession(context.Context, *SessionRequest) (*AddSessionResponse, error)
	// Obtains the session
	GetSession(context.Context, *SessionId) (*SessionResponse, error)
	// Delete a session
	DeleteSession(context.Context, *SessionId) (*SessionResponse, error)
	mustEmbedUnimplementedSessionTableServer()
}

// UnimplementedSessionTableServer must be embedded to have forward compatible implementations.
type UnimplementedSessionTableServer struct {
}

func (*UnimplementedSessionTableServer) AddSession(context.Context, *SessionRequest) (*AddSessionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddSession not implemented")
}
func (*UnimplementedSessionTableServer) GetSession(context.Context, *SessionId) (*SessionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSession not implemented")
}
func (*UnimplementedSessionTableServer) DeleteSession(context.Context, *SessionId) (*SessionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteSession not implemented")
}
func (*UnimplementedSessionTableServer) mustEmbedUnimplementedSessionTableServer() {}

func RegisterSessionTableServer(s *grpc.Server, srv SessionTableServer) {
	s.RegisterService(&_SessionTable_serviceDesc, srv)
}

func _SessionTable_AddSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SessionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SessionTableServer).AddSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/openoffload.v1alpha2.SessionTable/AddSession",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SessionTableServer).AddSession(ctx, req.(*SessionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SessionTable_GetSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SessionId)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SessionTableServer).GetSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/openoffload.v1alpha2.SessionTable/GetSession",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SessionTableServer).GetSession(ctx, req.(*SessionId))
	}
	return interceptor(ctx, in, info, handler)
}

func _SessionTable_DeleteSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SessionId)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SessionTableServer).DeleteSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/openoffload.v1alpha2.SessionTable/DeleteSession",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SessionTableServer).DeleteSession(ctx, req.(*SessionId))
	}
	return interceptor(ctx, in, info, handler)
}

var _SessionTable_serviceDesc = grpc.ServiceDesc{
	ServiceName: "openoffload.v1alpha2.SessionTable",
	HandlerType: (*SessionTableServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "addSession",
			Handler:    _SessionTable_AddSession_Handler,
		},
		{
			MethodName: "getSession",
			Handler:    _SessionTable_GetSession_Handler,
		},
		{
			MethodName: "deleteSession",
			Handler:    _SessionTable_DeleteSession_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "openoffload.proto",
}

// SessionStatisticsTableClient is the client API for SessionStatisticsTable service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type SessionStatisticsTableClient interface {
	// Stream back all current sessions
	GetAllSessions(ctx context.Context, in *StatisticsRequestArgs, opts ...grpc.CallOption) (SessionStatisticsTable_GetAllSessionsClient, error)
	// statistics as a outgoing session from the WB to Applications ?
	// grpc seems to need a request input streamId is a placeholder
	GetClosedSessions(ctx context.Context, in *StatisticsRequestArgs, opts ...grpc.CallOption) (SessionStatisticsTable_GetClosedSessionsClient, error)
}

type sessionStatisticsTableClient struct {
	cc grpc.ClientConnInterface
}

func NewSessionStatisticsTableClient(cc grpc.ClientConnInterface) SessionStatisticsTableClient {
	return &sessionStatisticsTableClient{cc}
}

func (c *sessionStatisticsTableClient) GetAllSessions(ctx context.Context, in *StatisticsRequestArgs, opts ...grpc.CallOption) (SessionStatisticsTable_GetAllSessionsClient, error) {
	stream, err := c.cc.NewStream(ctx, &_SessionStatisticsTable_serviceDesc.Streams[0], "/openoffload.v1alpha2.SessionStatisticsTable/getAllSessions", opts...)
	if err != nil {
		return nil, err
	}
	x := &sessionStatisticsTableGetAllSessionsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type SessionStatisticsTable_GetAllSessionsClient interface {
	Recv() (*SessionResponse, error)
	grpc.ClientStream
}

type sessionStatisticsTableGetAllSessionsClient struct {
	grpc.ClientStream
}

func (x *sessionStatisticsTableGetAllSessionsClient) Recv() (*SessionResponse, error) {
	m := new(SessionResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *sessionStatisticsTableClient) GetClosedSessions(ctx context.Context, in *StatisticsRequestArgs, opts ...grpc.CallOption) (SessionStatisticsTable_GetClosedSessionsClient, error) {
	stream, err := c.cc.NewStream(ctx, &_SessionStatisticsTable_serviceDesc.Streams[1], "/openoffload.v1alpha2.SessionStatisticsTable/getClosedSessions", opts...)
	if err != nil {
		return nil, err
	}
	x := &sessionStatisticsTableGetClosedSessionsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type SessionStatisticsTable_GetClosedSessionsClient interface {
	Recv() (*SessionResponse, error)
	grpc.ClientStream
}

type sessionStatisticsTableGetClosedSessionsClient struct {
	grpc.ClientStream
}

func (x *sessionStatisticsTableGetClosedSessionsClient) Recv() (*SessionResponse, error) {
	m := new(SessionResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// SessionStatisticsTableServer is the server API for SessionStatisticsTable service.
// All implementations must embed UnimplementedSessionStatisticsTableServer
// for forward compatibility
type SessionStatisticsTableServer interface {
	// Stream back all current sessions
	GetAllSessions(*StatisticsRequestArgs, SessionStatisticsTable_GetAllSessionsServer) error
	// statistics as a outgoing session from the WB to Applications ?
	// grpc seems to need a request input streamId is a placeholder
	GetClosedSessions(*StatisticsRequestArgs, SessionStatisticsTable_GetClosedSessionsServer) error
	mustEmbedUnimplementedSessionStatisticsTableServer()
}

// UnimplementedSessionStatisticsTableServer must be embedded to have forward compatible implementations.
type UnimplementedSessionStatisticsTableServer struct {
}

func (*UnimplementedSessionStatisticsTableServer) GetAllSessions(*StatisticsRequestArgs, SessionStatisticsTable_GetAllSessionsServer) error {
	return status.Errorf(codes.Unimplemented, "method GetAllSessions not implemented")
}
func (*UnimplementedSessionStatisticsTableServer) GetClosedSessions(*StatisticsRequestArgs, SessionStatisticsTable_GetClosedSessionsServer) error {
	return status.Errorf(codes.Unimplemented, "method GetClosedSessions not implemented")
}
func (*UnimplementedSessionStatisticsTableServer) mustEmbedUnimplementedSessionStatisticsTableServer() {
}

func RegisterSessionStatisticsTableServer(s *grpc.Server, srv SessionStatisticsTableServer) {
	s.RegisterService(&_SessionStatisticsTable_serviceDesc, srv)
}

func _SessionStatisticsTable_GetAllSessions_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(StatisticsRequestArgs)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(SessionStatisticsTableServer).GetAllSessions(m, &sessionStatisticsTableGetAllSessionsServer{stream})
}

type SessionStatisticsTable_GetAllSessionsServer interface {
	Send(*SessionResponse) error
	grpc.ServerStream
}

type sessionStatisticsTableGetAllSessionsServer struct {
	grpc.ServerStream
}

func (x *sessionStatisticsTableGetAllSessionsServer) Send(m *SessionResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _SessionStatisticsTable_GetClosedSessions_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(StatisticsRequestArgs)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(SessionStatisticsTableServer).GetClosedSessions(m, &sessionStatisticsTableGetClosedSessionsServer{stream})
}

type SessionStatisticsTable_GetClosedSessionsServer interface {
	Send(*SessionResponse) error
	grpc.ServerStream
}

type sessionStatisticsTableGetClosedSessionsServer struct {
	grpc.ServerStream
}

func (x *sessionStatisticsTableGetClosedSessionsServer) Send(m *SessionResponse) error {
	return x.ServerStream.SendMsg(m)
}

var _SessionStatisticsTable_serviceDesc = grpc.ServiceDesc{
	ServiceName: "openoffload.v1alpha2.SessionStatisticsTable",
	HandlerType: (*SessionStatisticsTableServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "getAllSessions",
			Handler:       _SessionStatisticsTable_GetAllSessions_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "getClosedSessions",
			Handler:       _SessionStatisticsTable_GetClosedSessions_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "openoffload.proto",
}

// ActivationClient is the client API for Activation service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ActivationClient interface {
	//
	// Device registeration
	//
	// Registration is the process of telling the network function that a offload device
	// is available for use and some metadata about the device. The metadata is there only
	// for the operator to make a decision on which device to activate.
	//
	RegisterOffloadDevice(ctx context.Context, in *DeviceDescription, opts ...grpc.CallOption) (*RegistrationStatus, error)
	DeregisterOffloadDevice(ctx context.Context, in *DeviceDescription, opts ...grpc.CallOption) (*RegistrationStatus, error)
	GetRegisteredOffloadDevices(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*DeviceList, error)
	//
	// Device activation
	//
	// Activation is the process of selecting a registered device and activating it on
	// the netwwork function. Currently only one network device is supported per network
	// element.
	//
	ActivateOffload(ctx context.Context, in *DeviceDescription, opts ...grpc.CallOption) (*ActivationStatus, error)
	DeactivateOffload(ctx context.Context, in *DeviceDescription, opts ...grpc.CallOption) (*ActivationStatus, error)
	GetActivatedOffload(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*DeviceDescription, error)
}

type activationClient struct {
	cc grpc.ClientConnInterface
}

func NewActivationClient(cc grpc.ClientConnInterface) ActivationClient {
	return &activationClient{cc}
}

func (c *activationClient) RegisterOffloadDevice(ctx context.Context, in *DeviceDescription, opts ...grpc.CallOption) (*RegistrationStatus, error) {
	out := new(RegistrationStatus)
	err := c.cc.Invoke(ctx, "/openoffload.v1alpha2.Activation/registerOffloadDevice", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *activationClient) DeregisterOffloadDevice(ctx context.Context, in *DeviceDescription, opts ...grpc.CallOption) (*RegistrationStatus, error) {
	out := new(RegistrationStatus)
	err := c.cc.Invoke(ctx, "/openoffload.v1alpha2.Activation/deregisterOffloadDevice", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *activationClient) GetRegisteredOffloadDevices(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*DeviceList, error) {
	out := new(DeviceList)
	err := c.cc.Invoke(ctx, "/openoffload.v1alpha2.Activation/getRegisteredOffloadDevices", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *activationClient) ActivateOffload(ctx context.Context, in *DeviceDescription, opts ...grpc.CallOption) (*ActivationStatus, error) {
	out := new(ActivationStatus)
	err := c.cc.Invoke(ctx, "/openoffload.v1alpha2.Activation/activateOffload", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *activationClient) DeactivateOffload(ctx context.Context, in *DeviceDescription, opts ...grpc.CallOption) (*ActivationStatus, error) {
	out := new(ActivationStatus)
	err := c.cc.Invoke(ctx, "/openoffload.v1alpha2.Activation/deactivateOffload", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *activationClient) GetActivatedOffload(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*DeviceDescription, error) {
	out := new(DeviceDescription)
	err := c.cc.Invoke(ctx, "/openoffload.v1alpha2.Activation/getActivatedOffload", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ActivationServer is the server API for Activation service.
// All implementations must embed UnimplementedActivationServer
// for forward compatibility
type ActivationServer interface {
	//
	// Device registeration
	//
	// Registration is the process of telling the network function that a offload device
	// is available for use and some metadata about the device. The metadata is there only
	// for the operator to make a decision on which device to activate.
	//
	RegisterOffloadDevice(context.Context, *DeviceDescription) (*RegistrationStatus, error)
	DeregisterOffloadDevice(context.Context, *DeviceDescription) (*RegistrationStatus, error)
	GetRegisteredOffloadDevices(context.Context, *Empty) (*DeviceList, error)
	//
	// Device activation
	//
	// Activation is the process of selecting a registered device and activating it on
	// the netwwork function. Currently only one network device is supported per network
	// element.
	//
	ActivateOffload(context.Context, *DeviceDescription) (*ActivationStatus, error)
	DeactivateOffload(context.Context, *DeviceDescription) (*ActivationStatus, error)
	GetActivatedOffload(context.Context, *Empty) (*DeviceDescription, error)
	mustEmbedUnimplementedActivationServer()
}

// UnimplementedActivationServer must be embedded to have forward compatible implementations.
type UnimplementedActivationServer struct {
}

func (*UnimplementedActivationServer) RegisterOffloadDevice(context.Context, *DeviceDescription) (*RegistrationStatus, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisterOffloadDevice not implemented")
}
func (*UnimplementedActivationServer) DeregisterOffloadDevice(context.Context, *DeviceDescription) (*RegistrationStatus, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeregisterOffloadDevice not implemented")
}
func (*UnimplementedActivationServer) GetRegisteredOffloadDevices(context.Context, *Empty) (*DeviceList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetRegisteredOffloadDevices not implemented")
}
func (*UnimplementedActivationServer) ActivateOffload(context.Context, *DeviceDescription) (*ActivationStatus, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ActivateOffload not implemented")
}
func (*UnimplementedActivationServer) DeactivateOffload(context.Context, *DeviceDescription) (*ActivationStatus, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeactivateOffload not implemented")
}
func (*UnimplementedActivationServer) GetActivatedOffload(context.Context, *Empty) (*DeviceDescription, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetActivatedOffload not implemented")
}
func (*UnimplementedActivationServer) mustEmbedUnimplementedActivationServer() {}

func RegisterActivationServer(s *grpc.Server, srv ActivationServer) {
	s.RegisterService(&_Activation_serviceDesc, srv)
}

func _Activation_RegisterOffloadDevice_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeviceDescription)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ActivationServer).RegisterOffloadDevice(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/openoffload.v1alpha2.Activation/RegisterOffloadDevice",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ActivationServer).RegisterOffloadDevice(ctx, req.(*DeviceDescription))
	}
	return interceptor(ctx, in, info, handler)
}

func _Activation_DeregisterOffloadDevice_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeviceDescription)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ActivationServer).DeregisterOffloadDevice(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/openoffload.v1alpha2.Activation/DeregisterOffloadDevice",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ActivationServer).DeregisterOffloadDevice(ctx, req.(*DeviceDescription))
	}
	return interceptor(ctx, in, info, handler)
}

func _Activation_GetRegisteredOffloadDevices_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ActivationServer).GetRegisteredOffloadDevices(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/openoffload.v1alpha2.Activation/GetRegisteredOffloadDevices",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ActivationServer).GetRegisteredOffloadDevices(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Activation_ActivateOffload_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeviceDescription)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ActivationServer).ActivateOffload(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/openoffload.v1alpha2.Activation/ActivateOffload",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ActivationServer).ActivateOffload(ctx, req.(*DeviceDescription))
	}
	return interceptor(ctx, in, info, handler)
}

func _Activation_DeactivateOffload_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeviceDescription)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ActivationServer).DeactivateOffload(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/openoffload.v1alpha2.Activation/DeactivateOffload",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ActivationServer).DeactivateOffload(ctx, req.(*DeviceDescription))
	}
	return interceptor(ctx, in, info, handler)
}

func _Activation_GetActivatedOffload_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ActivationServer).GetActivatedOffload(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/openoffload.v1alpha2.Activation/GetActivatedOffload",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ActivationServer).GetActivatedOffload(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

var _Activation_serviceDesc = grpc.ServiceDesc{
	ServiceName: "openoffload.v1alpha2.Activation",
	HandlerType: (*ActivationServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "registerOffloadDevice",
			Handler:    _Activation_RegisterOffloadDevice_Handler,
		},
		{
			MethodName: "deregisterOffloadDevice",
			Handler:    _Activation_DeregisterOffloadDevice_Handler,
		},
		{
			MethodName: "getRegisteredOffloadDevices",
			Handler:    _Activation_GetRegisteredOffloadDevices_Handler,
		},
		{
			MethodName: "activateOffload",
			Handler:    _Activation_ActivateOffload_Handler,
		},
		{
			MethodName: "deactivateOffload",
			Handler:    _Activation_DeactivateOffload_Handler,
		},
		{
			MethodName: "getActivatedOffload",
			Handler:    _Activation_GetActivatedOffload_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "openoffload.proto",
}
